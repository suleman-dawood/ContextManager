# Context Manager - Simplified Implementation Plan

> **Target**: Under 5000 lines total  
> **Timeline**: 2-3 weeks  
> **Focus**: AI-powered task suggestions with clean, simple code

---

## üì¶ Project Structure (Single Solution, Keep It Simple)

```
ContextManager/
‚îú‚îÄ‚îÄ ContextManager.API/              # Single .NET project
‚îÇ   ‚îú‚îÄ‚îÄ Models/                      # Entity classes (~300 lines)
‚îÇ   ‚îú‚îÄ‚îÄ Data/                        # DbContext (~150 lines)
‚îÇ   ‚îú‚îÄ‚îÄ Controllers/                 # API endpoints (~600 lines)
‚îÇ   ‚îú‚îÄ‚îÄ Services/                    # ClaudeService, AuthService (~400 lines)
‚îÇ   ‚îú‚îÄ‚îÄ DTOs/                        # Request/Response models (~200 lines)
‚îÇ   ‚îú‚îÄ‚îÄ Migrations/                  # Auto-generated by EF
‚îÇ   ‚îú‚îÄ‚îÄ Program.cs                   # App configuration (~100 lines)
‚îÇ   ‚îî‚îÄ‚îÄ appsettings.json            
‚îÇ
‚îî‚îÄ‚îÄ frontend/                        # React + TypeScript
    ‚îú‚îÄ‚îÄ src/
    ‚îÇ   ‚îú‚îÄ‚îÄ components/              # UI components (~1000 lines)
    ‚îÇ   ‚îú‚îÄ‚îÄ pages/                   # 4 main pages (~800 lines)
    ‚îÇ   ‚îú‚îÄ‚îÄ services/                # API calls (~300 lines)
    ‚îÇ   ‚îú‚îÄ‚îÄ types/                   # TypeScript interfaces (~150 lines)
    ‚îÇ   ‚îî‚îÄ‚îÄ App.tsx                  # Routing (~100 lines)
    ‚îî‚îÄ‚îÄ package.json

Total Estimate: ~4,100 lines ‚úÖ
```

---

## üóÑÔ∏è Database Setup (Railway PostgreSQL)

### How It Works:
1. **Local Development**: Use local PostgreSQL or Railway dev database
2. **Production**: Railway provisions PostgreSQL automatically
3. **Connection**: Railway provides `DATABASE_URL` environment variable
4. **Migrations**: EF Core handles schema creation

### Step-by-Step Railway Integration:

**1. Create Railway Project**
```bash
# Railway will give you a connection string like:
# postgresql://user:pass@containers-us-west-1.railway.app:5432/railway
```

**2. Configure Connection String (appsettings.json)**
```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Database=contextmanager;Username=postgres;Password=postgres"
  }
}
```

**3. Override with Environment Variable (Production)**
Railway automatically sets `DATABASE_URL`. Parse it in `Program.cs`:

```csharp
// Program.cs - handles both local and Railway connection
var builder = WebApplication.CreateBuilder(args);

// Get connection string (Railway or local)
var connectionString = Environment.GetEnvironmentVariable("DATABASE_URL");
if (!string.IsNullOrEmpty(connectionString))
{
    // Railway format: postgresql://user:pass@host:5432/db
    // EF Core format: Host=host;Database=db;Username=user;Password=pass
    connectionString = ConvertRailwayConnectionString(connectionString);
}
else
{
    connectionString = builder.Configuration.GetConnectionString("DefaultConnection");
}

builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseNpgsql(connectionString));

// Helper method
string ConvertRailwayConnectionString(string railwayUrl)
{
    var uri = new Uri(railwayUrl);
    return $"Host={uri.Host};Port={uri.Port};Database={uri.AbsolutePath.TrimStart('/')};Username={uri.UserInfo.Split(':')[0]};Password={uri.UserInfo.Split(':')[1]};SSL Mode=Require;Trust Server Certificate=true";
}
```

**4. Run Migrations on Deploy**
```bash
# Automatically runs on Railway startup
dotnet ef database update
```

**That's it!** Railway handles the rest. No complex setup needed.

---

## üéØ Core Features (Keep It Simple)

### What We're Building:
1. ‚úÖ **User Authentication** - Register/Login with JWT
2. ‚úÖ **Task Management** - CRUD with context tags
3. ‚úÖ **AI Suggestions** - Claude API recommends tasks (‚≠ê STAR FEATURE)
4. ‚úÖ **Simple Dashboard** - Task counts by context + completion rate chart
5. ‚úÖ **Context Filtering** - View tasks by Deep Work/Meetings/Admin/Creative/Learning

### What We're NOT Building:
- ‚ùå Focus sessions (too complex)
- ‚ùå Context switch tracking (not core)
- ‚ùå Complex analytics (keep it simple)
- ‚ùå Repository pattern (direct DbContext usage)
- ‚ùå Multiple projects (single API project)

---

## üìä Database Models (6 Tables, Keep It Simple)

### 1. Users
```csharp
public class User
{
    public Guid Id { get; set; }
    public string Email { get; set; }
    public string Name { get; set; }
    public string PasswordHash { get; set; }
    public DateTime CreatedAt { get; set; }
}
```

### 2. Contexts (Pre-seeded, Read-Only)
```csharp
public class Context
{
    public Guid Id { get; set; }
    public string Name { get; set; }          // "Deep Work", "Meetings", etc.
    public string Description { get; set; }
    public string Color { get; set; }         // Hex color for UI
    public string Icon { get; set; }
}
```

### 3. Tasks (Main Entity)
```csharp
public class Task
{
    public Guid Id { get; set; }
    public Guid UserId { get; set; }
    public Guid ContextId { get; set; }
    public string Title { get; set; }
    public string Description { get; set; }
    public int EstimatedMinutes { get; set; }
    public Priority Priority { get; set; }
    public TaskStatus Status { get; set; }
    public DateTime? DueDate { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime? CompletedAt { get; set; }
    
    // Navigation
    public User User { get; set; }
    public Context Context { get; set; }
}

public enum Priority { Low, Medium, High }
public enum TaskStatus { Todo, InProgress, Completed }
```

### 4. TaskSuggestions (AI History)
```csharp
public class TaskSuggestion
{
    public Guid Id { get; set; }
    public Guid UserId { get; set; }
    public Guid TaskId { get; set; }
    public Guid ContextId { get; set; }
    public float ConfidenceScore { get; set; }
    public string Reasoning { get; set; }
    public DateTime CreatedAt { get; set; }
    public bool? UserAccepted { get; set; }    // Feedback for improvement
    
    // Navigation
    public User User { get; set; }
    public Task Task { get; set; }
    public Context Context { get; set; }
}
```

### DbContext (~150 lines)
```csharp
public class ApplicationDbContext : DbContext
{
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
        : base(options) { }

    public DbSet<User> Users { get; set; }
    public DbSet<Context> Contexts { get; set; }
    public DbSet<Task> Tasks { get; set; }
    public DbSet<TaskSuggestion> TaskSuggestions { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // Configure relationships
        modelBuilder.Entity<Task>()
            .HasOne(t => t.User)
            .WithMany()
            .HasForeignKey(t => t.UserId)
            .OnDelete(DeleteBehavior.Cascade);

        // Seed default contexts
        modelBuilder.Entity<Context>().HasData(
            new Context { Id = Guid.Parse("..."), Name = "Deep Work", Color = "#3B82F6", Icon = "brain", Description = "Complex problem-solving, coding, writing" },
            new Context { Id = Guid.Parse("..."), Name = "Meetings", Color = "#10B981", Icon = "users", Description = "Collaborative sessions, discussions" },
            new Context { Id = Guid.Parse("..."), Name = "Admin", Color = "#F59E0B", Icon = "clipboard", Description = "Email, scheduling, documentation" },
            new Context { Id = Guid.Parse("..."), Name = "Creative", Color = "#8B5CF6", Icon = "palette", Description = "Brainstorming, design, prototyping" },
            new Context { Id = Guid.Parse("..."), Name = "Learning", Color = "#EC4899", Icon = "book", Description = "Reading, courses, skill development" }
        );
    }
}
```

---

## üîå API Endpoints (Keep It Minimal)

### Authentication (2 endpoints)
```
POST /api/auth/register
POST /api/auth/login
```

### Tasks (5 endpoints)
```
GET    /api/tasks              # List user's tasks (filter by context, status)
POST   /api/tasks              # Create new task
GET    /api/tasks/{id}         # Get single task
PUT    /api/tasks/{id}         # Update task
DELETE /api/tasks/{id}         # Delete task
```

### Contexts (1 endpoint)
```
GET /api/contexts              # List all 5 contexts (pre-seeded)
```

### AI Suggestions (2 endpoints) ‚≠ê
```
GET  /api/suggestions?contextId={guid}    # Get AI task suggestions
POST /api/suggestions/{id}/feedback       # User accepts/rejects suggestion
```

### Analytics (2 endpoints)
```
GET /api/analytics/context-distribution   # Task counts per context
GET /api/analytics/completion-rate        # Completion rate over time
```

**Total: 12 endpoints** (simple and clean)

---

## ü§ñ AI Integration (The Star Feature)

### ClaudeService.cs (~300 lines)

```csharp
public class ClaudeService
{
    private readonly HttpClient _httpClient;
    private readonly string _apiKey;

    public async Task<List<TaskSuggestionDto>> GetSuggestionsAsync(
        Guid userId, 
        Guid contextId, 
        ApplicationDbContext db)
    {
        // 1. Get user's pending tasks for this context
        var tasks = await db.Tasks
            .Where(t => t.UserId == userId 
                     && t.ContextId == contextId 
                     && t.Status != TaskStatus.Completed)
            .ToListAsync();

        if (!tasks.Any()) return new List<TaskSuggestionDto>();

        // 2. Get context details
        var context = await db.Contexts.FindAsync(contextId);

        // 3. Build Claude prompt
        var prompt = BuildPrompt(context, tasks);

        // 4. Call Claude API
        var request = new
        {
            model = "claude-3-5-sonnet-20241022",
            max_tokens = 1024,
            messages = new[]
            {
                new { role = "user", content = prompt }
            }
        };

        var response = await _httpClient.PostAsJsonAsync(
            "https://api.anthropic.com/v1/messages", 
            request
        );

        var result = await response.Content.ReadFromJsonAsync<ClaudeResponse>();

        // 5. Parse response and save suggestions
        var suggestions = ParseSuggestions(result, tasks);
        
        foreach (var suggestion in suggestions)
        {
            db.TaskSuggestions.Add(new TaskSuggestion
            {
                Id = Guid.NewGuid(),
                UserId = userId,
                TaskId = suggestion.TaskId,
                ContextId = contextId,
                ConfidenceScore = suggestion.Confidence,
                Reasoning = suggestion.Reasoning,
                CreatedAt = DateTime.UtcNow
            });
        }
        await db.SaveChangesAsync();

        return suggestions;
    }

    private string BuildPrompt(Context context, List<Task> tasks)
    {
        var currentHour = DateTime.Now.Hour;
        var timeOfDay = currentHour < 12 ? "morning" : currentHour < 17 ? "afternoon" : "evening";

        return $@"You are a productivity assistant helping a user prioritize tasks for their {context.Name} context.

Context: {context.Name} - {context.Description}
Current Time: {timeOfDay} ({DateTime.Now:HH:mm})

Available Tasks:
{string.Join("\n", tasks.Select((t, i) => 
    $"{i + 1}. [{t.Title}] - Priority: {t.Priority}, Estimated: {t.EstimatedMinutes}min" +
    (t.DueDate.HasValue ? $", Due: {t.DueDate.Value:MMM dd}" : "")
))}

Instructions:
1. Suggest the TOP 3 tasks that best fit this context right now
2. Consider time of day, priority, estimated time, and deadlines
3. Provide a brief reasoning for each suggestion

Respond ONLY with valid JSON in this format:
{{
  ""suggestions"": [
    {{
      ""taskNumber"": 1,
      ""confidence"": 0.95,
      ""reasoning"": ""High-priority coding task ideal for deep work in the morning""
    }}
  ]
}}";
    }

    private List<TaskSuggestionDto> ParseSuggestions(ClaudeResponse response, List<Task> tasks)
    {
        // Parse Claude's JSON response
        var content = response.Content[0].Text;
        var json = JsonDocument.Parse(content);
        var suggestions = new List<TaskSuggestionDto>();

        foreach (var item in json.RootElement.GetProperty("suggestions").EnumerateArray())
        {
            var taskNumber = item.GetProperty("taskNumber").GetInt32();
            var task = tasks[taskNumber - 1];

            suggestions.Add(new TaskSuggestionDto
            {
                TaskId = task.Id,
                TaskTitle = task.Title,
                Confidence = (float)item.GetProperty("confidence").GetDouble(),
                Reasoning = item.GetProperty("reasoning").GetString()
            });
        }

        return suggestions;
    }
}

public class TaskSuggestionDto
{
    public Guid TaskId { get; set; }
    public string TaskTitle { get; set; }
    public float Confidence { get; set; }
    public string Reasoning { get; set; }
}
```

### SuggestionsController.cs
```csharp
[ApiController]
[Route("api/[controller]")]
[Authorize]
public class SuggestionsController : ControllerBase
{
    private readonly ApplicationDbContext _db;
    private readonly ClaudeService _claudeService;

    [HttpGet]
    public async Task<IActionResult> GetSuggestions([FromQuery] Guid contextId)
    {
        var userId = GetUserIdFromToken();
        var suggestions = await _claudeService.GetSuggestionsAsync(userId, contextId, _db);
        return Ok(suggestions);
    }

    [HttpPost("{suggestionId}/feedback")]
    public async Task<IActionResult> ProvideFeedback(Guid suggestionId, [FromBody] FeedbackDto feedback)
    {
        var suggestion = await _db.TaskSuggestions.FindAsync(suggestionId);
        if (suggestion == null) return NotFound();

        suggestion.UserAccepted = feedback.Accepted;
        await _db.SaveChangesAsync();

        return Ok();
    }
}
```

---

## üé® Frontend (React + TypeScript)

### Page Structure (4 Pages Only)
```
1. Login.tsx           (~150 lines)
2. Dashboard.tsx       (~300 lines) - Main view with task list + context filter
3. Analytics.tsx       (~200 lines) - 2 simple charts
4. Settings.tsx        (~100 lines) - User profile
```

### Key Components (~1000 lines total)
```
components/
‚îú‚îÄ‚îÄ TaskList.tsx           (~200 lines) - Display tasks with filters
‚îú‚îÄ‚îÄ TaskCard.tsx           (~100 lines) - Individual task item
‚îú‚îÄ‚îÄ CreateTaskModal.tsx    (~150 lines) - Form to add new task
‚îú‚îÄ‚îÄ EditTaskModal.tsx      (~150 lines) - Form to edit task
‚îú‚îÄ‚îÄ ContextFilter.tsx      (~80 lines)  - Filter tabs by context
‚îú‚îÄ‚îÄ AISuggestions.tsx      (~200 lines) - Display Claude's suggestions ‚≠ê
‚îú‚îÄ‚îÄ ConfidenceBar.tsx      (~50 lines)  - Visual confidence score
‚îî‚îÄ‚îÄ StatsCards.tsx         (~70 lines)  - Simple stats dashboard
```

### AI Suggestions Component (The Showcase) ‚≠ê
```typescript
// AISuggestions.tsx
export const AISuggestions: React.FC<{ contextId: string }> = ({ contextId }) => {
  const [suggestions, setSuggestions] = useState<Suggestion[]>([]);
  const [loading, setLoading] = useState(false);

  const fetchSuggestions = async () => {
    setLoading(true);
    const response = await api.get(`/api/suggestions?contextId=${contextId}`);
    setSuggestions(response.data);
    setLoading(false);
  };

  const provideFeedback = async (suggestionId: string, accepted: boolean) => {
    await api.post(`/api/suggestions/${suggestionId}/feedback`, { accepted });
    // Update UI to show feedback was recorded
  };

  return (
    <div className="ai-suggestions">
      <button onClick={fetchSuggestions} disabled={loading}>
        {loading ? 'ü§î AI is thinking...' : '‚ú® Get AI Task Suggestions'}
      </button>

      {suggestions.map(suggestion => (
        <div key={suggestion.taskId} className="suggestion-card">
          <div className="task-info">
            <h3>{suggestion.taskTitle}</h3>
            <ConfidenceBar score={suggestion.confidence} />
          </div>
          
          <p className="reasoning">{suggestion.reasoning}</p>
          
          <div className="actions">
            <button onClick={() => provideFeedback(suggestion.id, true)}>
              ‚úÖ Good Suggestion
            </button>
            <button onClick={() => provideFeedback(suggestion.id, false)}>
              ‚ùå Not Helpful
            </button>
          </div>
        </div>
      ))}
    </div>
  );
};
```

### Analytics Page (Simple)
```typescript
// Analytics.tsx - Just 2 charts
import { PieChart, Pie, LineChart, Line, ResponsiveContainer } from 'recharts';

export const Analytics: React.FC = () => {
  const [contextDistribution, setContextDistribution] = useState([]);
  const [completionRate, setCompletionRate] = useState([]);

  useEffect(() => {
    // Fetch analytics data
    api.get('/api/analytics/context-distribution').then(res => setContextDistribution(res.data));
    api.get('/api/analytics/completion-rate').then(res => setCompletionRate(res.data));
  }, []);

  return (
    <div className="analytics">
      <h2>Your Productivity Insights</h2>
      
      {/* Chart 1: Task distribution by context */}
      <div className="chart-container">
        <h3>Tasks by Context</h3>
        <ResponsiveContainer width="100%" height={300}>
          <PieChart>
            <Pie data={contextDistribution} dataKey="count" nameKey="context" />
          </PieChart>
        </ResponsiveContainer>
      </div>

      {/* Chart 2: Completion rate over last 7 days */}
      <div className="chart-container">
        <h3>Completion Rate (Last 7 Days)</h3>
        <ResponsiveContainer width="100%" height={300}>
          <LineChart data={completionRate}>
            <Line type="monotone" dataKey="rate" stroke="#8884d8" />
          </LineChart>
        </ResponsiveContainer>
      </div>
    </div>
  );
};
```

---

## üöÄ Railway Deployment (Dead Simple)

### Step 1: Prepare Backend for Railway
**Update Program.cs** (already shown above with connection string converter)

### Step 2: Create Railway Project
```bash
# Option 1: Railway CLI
railway init
railway up

# Option 2: Connect GitHub repo via Railway dashboard
```

### Step 3: Add PostgreSQL
```
Railway Dashboard ‚Üí Add Service ‚Üí PostgreSQL
```
Railway automatically sets `DATABASE_URL` environment variable.

### Step 4: Set Environment Variables
```
ANTHROPIC_API_KEY=your-claude-key
JWT_SECRET=your-secure-secret-minimum-32-chars
ASPNETCORE_ENVIRONMENT=Production
```

### Step 5: Deploy!
```bash
git push origin main  # Railway auto-deploys on push
```

**That's it!** No Docker configs needed (Railway handles it).

### Migrations on Railway
Add to `.csproj`:
```xml
<PropertyGroup>
  <RunPostBuildEvent>OnOutputUpdated</RunPostBuildEvent>
</PropertyGroup>

<Target Name="ApplyMigrations" AfterTargets="Build">
  <Exec Command="dotnet ef database update" />
</Target>
```

Or run manually via Railway CLI:
```bash
railway run dotnet ef database update
```

---

## ‚è±Ô∏è Realistic Timeline

### Week 1: Backend
- **Day 1-2**: Setup, models, DbContext, migrations
- **Day 3**: Auth (register/login with JWT)
- **Day 4**: Task CRUD endpoints
- **Day 5**: Claude AI integration

### Week 2: Frontend
- **Day 6-7**: React setup, auth pages, routing
- **Day 8-9**: Task list, create/edit/delete UI
- **Day 10**: AI Suggestions component (showcase feature)

### Week 3: Polish & Deploy
- **Day 11**: Analytics page (2 simple charts)
- **Day 12**: UI polish, error handling, loading states
- **Day 13**: Railway deployment
- **Day 14**: Testing, bug fixes, documentation

---

## üìè Line Count Breakdown

| Component | Lines | Notes |
|-----------|-------|-------|
| **Backend** |
| Models | 200 | 4 entity classes + enums |
| DbContext | 150 | Context + seed data |
| Controllers | 600 | 4 controllers (Auth, Tasks, Suggestions, Analytics) |
| ClaudeService | 300 | AI integration logic |
| AuthService | 150 | JWT generation/validation |
| DTOs | 150 | Request/response models |
| Program.cs | 100 | Startup configuration |
| **Subtotal** | **1,650** | |
| **Frontend** |
| Components | 1,000 | 8 components |
| Pages | 750 | 4 pages |
| Services | 300 | API client services |
| Types | 150 | TypeScript interfaces |
| App.tsx | 100 | Routing setup |
| **Subtotal** | **2,300** | |
| **Config/Other** | 200 | appsettings, package.json, etc |
| **GRAND TOTAL** | **4,150** | ‚úÖ Under 5000! |

---

## ‚úÖ Final Portfolio Project Checklist

**Core Features**:
- [x] User authentication with JWT
- [x] Task CRUD with context tags
- [x] AI-powered task suggestions (Claude API) ‚≠ê
- [x] Simple analytics (2 charts)
- [x] Context filtering

**Technical Skills Demonstrated**:
- [x] .NET 8 / C# backend development
- [x] Entity Framework Core with PostgreSQL
- [x] RESTful API design
- [x] JWT authentication
- [x] AI/LLM integration (Claude API)
- [x] React + TypeScript frontend
- [x] API integration with Axios
- [x] Data visualization (Recharts)
- [x] Railway deployment
- [x] Clean, maintainable code

**Portfolio Ready**:
- [x] Under 5000 lines (realistic scope)
- [x] Unique selling point (AI suggestions)
- [x] Clean architecture (single project, not over-engineered)
- [x] Production deployment
- [x] Professional UI

---

## üéØ The Elevator Pitch

> "Context Manager is a task management app that uses Claude AI to intelligently suggest which tasks you should work on based on your current mental mode. Built with .NET 8, React, and PostgreSQL, it demonstrates full-stack development skills and practical AI integration."

**What makes it stand out**: The AI suggestion feature isn't just a gimmick‚Äîit solves a real problem (context switching) with smart, contextual recommendations.

---

**This is realistic, achievable, and impressive for a portfolio project. Let's build it! üöÄ**

