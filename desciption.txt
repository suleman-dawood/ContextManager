# Context Manager - Full Project Implementation Prompt

## Project Overview
Build a full-stack task management application called "Context Manager" that organizes tasks by work context (Deep Work, Meetings, Admin, Creative, Learning) to minimize context-switching overhead. The application will use AI to intelligently categorize tasks and suggest optimal task selection based on current work mode.

## Tech Stack Requirements

### Backend
- **Framework:** ASP.NET Core 8 Web API
- **Database:** PostgreSQL (Railway)
- **ORM:** Entity Framework Core with Code-First approach
- **Architecture:** Clean architecture with Controllers, Services, Models, DTOs
- **API Style:** RESTful API with proper HTTP status codes

### Frontend
- **Framework:** React 18 with TypeScript
- **Styling:** Tailwind CSS (utility classes only)
- **Routing:** React Router v6
- **State Management:** React Query (TanStack Query) for server state
- **HTTP Client:** Axios

### AI Integration
- **Provider:** Anthropic Claude API
- **Purpose:** Task context classification, task breakdown suggestions, energy level estimation

### Deployment
- **Platform:** Railway
- **Database:** Railway PostgreSQL (use built-in connection string)
- **Environment:** Production-ready configuration

## Project Structure

### Backend Structure (`/backend`)
```
backend/
â”œâ”€â”€ Controllers/
â”‚   â”œâ”€â”€ TasksController.cs
â”‚   â”œâ”€â”€ ContextsController.cs
â”‚   â”œâ”€â”€ AIController.cs
â”‚   â””â”€â”€ UsersController.cs
â”œâ”€â”€ Models/
â”‚   â”œâ”€â”€ Task.cs
â”‚   â”œâ”€â”€ Context.cs
â”‚   â”œâ”€â”€ User.cs
â”‚   â””â”€â”€ DTOs/
â”‚       â”œâ”€â”€ TaskCreateDto.cs
â”‚       â”œâ”€â”€ TaskUpdateDto.cs
â”‚       â”œâ”€â”€ TaskResponseDto.cs
â”‚       â”œâ”€â”€ AITaskSuggestionDto.cs
â”‚       â””â”€â”€ ContextStatsDto.cs
â”œâ”€â”€ Services/
â”‚   â”œâ”€â”€ ITaskService.cs
â”‚   â”œâ”€â”€ TaskService.cs
â”‚   â”œâ”€â”€ IAIService.cs
â”‚   â”œâ”€â”€ AIService.cs
â”‚   â”œâ”€â”€ IContextService.cs
â”‚   â””â”€â”€ ContextService.cs
â”œâ”€â”€ Data/
â”‚   â”œâ”€â”€ AppDbContext.cs
â”‚   â””â”€â”€ Migrations/
â”œâ”€â”€ Program.cs
â”œâ”€â”€ appsettings.json
â””â”€â”€ appsettings.Development.json
```

### Frontend Structure (`/frontend`)
```
frontend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ TaskList.tsx
â”‚   â”‚   â”œâ”€â”€ TaskCard.tsx
â”‚   â”‚   â”œâ”€â”€ TaskForm.tsx
â”‚   â”‚   â”œâ”€â”€ ContextView.tsx
â”‚   â”‚   â”œâ”€â”€ Dashboard.tsx
â”‚   â”‚   â”œâ”€â”€ AIAssistant.tsx
â”‚   â”‚   â”œâ”€â”€ ContextSelector.tsx
â”‚   â”‚   â””â”€â”€ Layout.tsx
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â””â”€â”€ api.ts
â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”œâ”€â”€ useTasks.ts
â”‚   â”‚   â”œâ”€â”€ useContexts.ts
â”‚   â”‚   â””â”€â”€ useAI.ts
â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â”œâ”€â”€ HomePage.tsx
â”‚   â”‚   â”œâ”€â”€ TasksPage.tsx
â”‚   â”‚   â””â”€â”€ AnalyticsPage.tsx
â”‚   â”œâ”€â”€ App.tsx
â”‚   â”œâ”€â”€ main.tsx
â”‚   â””â”€â”€ index.css
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ tailwind.config.js
â””â”€â”€ vite.config.ts
```

## Database Schema Design

### Tables and Relationships

**Users Table:**
- Id (int, primary key, auto-increment)
- Username (string, unique, required)
- Email (string, unique, required)
- CreatedAt (datetime)

**Contexts Table:**
- Id (int, primary key, auto-increment)
- Name (string, required) - e.g., "Deep Work", "Meetings", "Admin", "Creative", "Learning"
- Description (string)
- ColorCode (string) - for UI display
- Icon (string) - emoji or icon name

**Tasks Table:**
- Id (int, primary key, auto-increment)
- Title (string, required)
- Description (string, nullable)
- ContextId (int, foreign key to Contexts)
- UserId (int, foreign key to Users)
- Status (enum: ToDo, InProgress, Done)
- Priority (enum: Low, Medium, High)
- EnergyLevel (enum: Low, Medium, High)
- EstimatedDuration (int, minutes, nullable)
- DueDate (datetime, nullable)
- CreatedAt (datetime)
- UpdatedAt (datetime)
- CompletedAt (datetime, nullable)

**Relationships:**
- User has many Tasks (one-to-many)
- Context has many Tasks (one-to-many)
- Task belongs to one User and one Context

### Seed Data
Pre-populate Contexts table with these five default contexts:
1. Deep Work - "Focused, complex tasks requiring concentration" - Blue - ðŸ§ 
2. Meetings - "Calls, discussions, collaborative sessions" - Purple - ðŸ’¬
3. Admin - "Quick tasks, emails, paperwork" - Gray - ðŸ“‹
4. Creative - "Design, writing, brainstorming" - Orange - ðŸŽ¨
5. Learning - "Reading, courses, research" - Green - ðŸ“š

## Backend Implementation Details

### Program.cs Configuration
- Configure CORS to allow frontend origin
- Add DbContext with PostgreSQL connection string from environment variable
- Register all services with dependency injection (Scoped lifetime)
- Add controllers and configure JSON serialization
- Configure Swagger for API documentation
- Set up Railway-specific port binding (use PORT environment variable)

### Models Implementation

**Task Model:**
- Include all properties from schema
- Add navigation properties for User and Context
- Use data annotations for validation (Required, MaxLength)
- Include enum definitions for Status, Priority, EnergyLevel

**Context Model:**
- Simple model with Id, Name, Description, ColorCode, Icon
- Navigation property for Tasks collection

**User Model:**
- Basic user info with navigation property for Tasks

**DTOs:**
- TaskCreateDto: Title, Description, ContextId, Priority, EnergyLevel, EstimatedDuration, DueDate
- TaskUpdateDto: Same as Create but all fields optional except Id
- TaskResponseDto: All Task fields plus Context name and color
- AITaskSuggestionDto: SuggestedContext, SuggestedPriority, SuggestedEnergyLevel, Reasoning
- ContextStatsDto: ContextName, TotalTasks, CompletedTasks, TotalTimeSpent

### TaskService Implementation
Methods to implement:
- GetAllTasksAsync(int userId) - return all tasks for user
- GetTasksByContextAsync(int userId, int contextId) - filter by context
- GetTasksByStatusAsync(int userId, Status status) - filter by status
- CreateTaskAsync(TaskCreateDto dto, int userId) - create new task
- UpdateTaskAsync(int taskId, TaskUpdateDto dto) - update existing task
- DeleteTaskAsync(int taskId) - soft delete or hard delete
- CompleteTaskAsync(int taskId) - mark as done, set CompletedAt
- GetTaskByIdAsync(int taskId) - get single task

Business logic:
- When creating task, set CreatedAt to current time
- When updating task, set UpdatedAt to current time
- When completing task, set Status to Done and CompletedAt to current time
- Validate that ContextId exists before creating/updating
- Return proper DTOs, not raw entities

### AIService Implementation
Methods to implement:
- AnalyzeTaskAsync(string title, string description) - returns AITaskSuggestionDto
- BreakdownComplexTaskAsync(string taskDescription) - returns list of subtask strings
- SuggestTasksForContextAsync(List<Task> availableTasks, Context currentContext) - returns prioritized task list

AI Integration Details:
- Use Anthropic Claude API (claude-sonnet-4-20250514 model)
- Store API key in environment variable: ANTHROPIC_API_KEY
- Implement retry logic for API failures
- Cache AI responses for identical task titles (in-memory cache, Dictionary<string, AITaskSuggestionDto>)
- Keep prompts concise to minimize API costs
- Handle rate limits gracefully

AI Prompts to use:
1. For AnalyzeTask: "Analyze this task and categorize it. Task: [title] - [description]. Which context does it fit: Deep Work (complex/focused), Meetings (collaborative), Admin (quick/simple), Creative (design/writing), or Learning (research/study)? Also suggest priority (Low/Medium/High) and energy level needed (Low/Medium/High). Respond in JSON format with: context, priority, energyLevel, reasoning."

2. For BreakdownTask: "Break down this complex task into 3-5 actionable subtasks. Task: [description]. Return as a simple JSON array of strings. Each subtask should be specific and achievable."

3. For SuggestTasks: "Given these tasks and the current work context '[context name]', suggest which 3-5 tasks would be best to work on now. Consider task context match, priority, and energy level. Tasks: [JSON array]. Return task IDs in priority order as JSON array."

### ContextService Implementation
Methods to implement:
- GetAllContextsAsync() - return all predefined contexts
- GetContextStatsAsync(int userId) - return stats for each context
- GetContextByIdAsync(int contextId) - get single context

Stats calculation:
- For each context, count total tasks, completed tasks
- Calculate total estimated time from tasks
- Calculate actual time if you track time spent

### Controllers Implementation

**TasksController:**
- GET /api/tasks - get all tasks for current user
- GET /api/tasks/{id} - get specific task
- GET /api/tasks/context/{contextId} - get tasks by context
- GET /api/tasks/status/{status} - get tasks by status
- POST /api/tasks - create new task
- PUT /api/tasks/{id} - update task
- DELETE /api/tasks/{id} - delete task
- POST /api/tasks/{id}/complete - mark task complete

**AIController:**
- POST /api/ai/analyze - analyze task and return suggestions (body: { title, description })
- POST /api/ai/breakdown - breakdown complex task (body: { description })
- POST /api/ai/suggest - suggest tasks for current context (body: { contextId })

**ContextsController:**
- GET /api/contexts - get all contexts
- GET /api/contexts/{id} - get specific context
- GET /api/contexts/stats - get stats for all contexts

All controllers should:
- Use [ApiController] attribute
- Return proper ActionResults (Ok, Created, NotFound, BadRequest)
- Include error handling with try-catch
- Validate input with ModelState
- Use async/await for all operations
- For simplicity, use userId = 1 (hardcoded) - no authentication needed for portfolio project

### Database Configuration
- Use PostgreSQL provider for Entity Framework
- Connection string format: "Host=host;Database=db;Username=user;Password=password"
- Get connection string from environment variable: DATABASE_URL or ConnectionStrings:DefaultConnection
- Handle Railway's DATABASE_URL format (may need parsing)
- Enable automatic migrations on startup for development
- Use UTC for all datetime values

### Error Handling
- Global exception handler middleware for unhandled exceptions
- Return consistent error response format: { error: "message", details: "..." }
- Log errors to console (Railway will capture logs)
- Specific handling for:
  - Task not found (404)
  - Invalid context (400)
  - AI API failures (503 or fallback)
  - Database connection issues (500)

## Frontend Implementation Details

### Project Setup
- Use Vite for React project
- Install dependencies: react-router-dom, @tanstack/react-query, axios, lucide-react (for icons)
- Configure Tailwind CSS with default theme
- Set up API base URL from environment variable: VITE_API_URL

### Type Definitions (types/index.ts)
Define TypeScript interfaces for:
- Task (matching backend TaskResponseDto)
- Context (matching backend Context)
- TaskFormData (for form inputs)
- AITaskSuggestion (matching backend AITaskSuggestionDto)
- ContextStats (matching backend ContextStatsDto)
- Enums for Status, Priority, EnergyLevel

### API Service (services/api.ts)
Create axios instance with baseURL from environment variable

Implement API functions:
- Tasks: fetchTasks, fetchTaskById, fetchTasksByContext, createTask, updateTask, deleteTask, completeTask
- Contexts: fetchContexts, fetchContextStats
- AI: analyzeTask, breakdownTask, suggestTasks

Include proper TypeScript typing for all functions
Handle errors and return meaningful messages
Set proper headers (Content-Type: application/json)

### React Query Hooks

**useTasks.ts:**
- useTasksQuery() - fetch all tasks with caching
- useTasksByContextQuery(contextId) - fetch filtered tasks
- useCreateTaskMutation() - create with optimistic update
- useUpdateTaskMutation() - update with optimistic update
- useDeleteTaskMutation() - delete with optimistic update
- useCompleteTaskMutation() - complete with optimistic update

Configure React Query:
- Enable refetchOnWindowFocus: false
- Set staleTime to 5 minutes
- Use optimistic updates for mutations
- Invalidate queries after mutations

**useContexts.ts:**
- useContextsQuery() - fetch all contexts
- useContextStatsQuery() - fetch context statistics

**useAI.ts:**
- useAnalyzeTaskMutation() - analyze task
- useBreakdownTaskMutation() - breakdown task
- useSuggestTasksMutation() - get suggestions

### Component Implementation

**Layout.tsx:**
- Main app shell with navigation
- Sidebar with context navigation
- Header with app title "Context Manager"
- Use Tailwind for responsive layout
- Navigation items: Dashboard, All Tasks, Analytics

**Dashboard.tsx:**
- Welcome message
- Quick stats cards: Total tasks, Completed today, Active contexts
- Context breakdown chart (simple bar or list representation)
- Recent tasks list (last 5-10 tasks)
- Quick action: "Add Task" button
- Use grid layout with Tailwind

**TaskList.tsx:**
Props: contextId (optional for filtering), status (optional)
- Display tasks in a grid or list
- Each task shows: title, context badge, priority indicator, due date, energy level
- Filter controls: by context, by status, by priority
- Sort options: by due date, by priority, by created date
- Empty state: "No tasks yet" with illustration or message
- Loading state: skeleton cards
- Map tasks to TaskCard components

**TaskCard.tsx:**
Props: task object
- Display task title (bold, larger text)
- Context badge (colored pill with context name)
- Priority indicator (colored dot or icon)
- Energy level indicator (âš¡ icons, 1-3)
- Due date (if set, with relative time like "in 2 days")
- Estimated duration (if set)
- Action buttons: Edit, Complete, Delete
- Hover effect: slight shadow elevation
- Click to expand/view details (optional)
- Use Tailwind for card styling

**TaskForm.tsx:**
Props: task (optional for editing), onSuccess callback
- Form fields:
  - Title (text input, required)
  - Description (textarea, optional)
  - Context (dropdown, required) - populate from contexts API
  - Priority (dropdown: Low, Medium, High)
  - Energy Level (dropdown: Low, Medium, High)
  - Estimated Duration (number input, minutes)
  - Due Date (date input, optional)
- AI suggestion button: "Get AI Suggestions"
- When clicked, call analyzeTask and pre-fill context, priority, energy
- Show AI reasoning in a small info box
- Submit button: "Create Task" or "Update Task"
- Cancel button
- Form validation: title required, context required
- Loading state during submission
- Use controlled inputs with useState

**ContextView.tsx:**
Props: contextId
- Display context name and description at top
- Show context icon and color
- Filter tasks to only show this context
- Display TaskList with filtered tasks
- Context stats: total tasks, completed, average duration
- "Add Task in this Context" button (pre-selects context)
- Use context color as accent throughout page

**AIAssistant.tsx:**
- Floating action button or sidebar panel
- Features:
  - "Analyze this task" - paste task description, get suggestions
  - "Break down complex task" - paste complex task, get subtasks
  - "What should I work on?" - get task suggestions for current context
- Show AI responses in formatted way
- Option to apply AI suggestions directly to task form
- Loading indicator during AI calls
- Error handling if AI fails

**ContextSelector.tsx:**
Props: selectedContextId, onSelect callback
- Horizontal list of context pills/cards
- Each shows: context icon, name, task count
- Highlight selected context
- Click to select/filter
- "All Contexts" option to clear filter
- Use context colors for visual distinction

### Pages Implementation

**HomePage.tsx:**
- Render Dashboard component
- Welcome message
- Overview of all contexts

**TasksPage.tsx:**
- Render TaskList with all tasks
- Filter and sort controls
- "Add Task" floating action button
- Modal or slide-out panel for TaskForm

**AnalyticsPage.tsx:**
- Context breakdown (tasks per context)
- Completion rate over time (simple chart or list)
- Most productive context
- Energy level distribution
- Use ContextStats data
- Simple visual representations (no complex charting library needed)

### App.tsx
- Set up React Router with routes:
  - / â†’ HomePage
  - /tasks â†’ TasksPage
  - /context/:id â†’ ContextView
  - /analytics â†’ AnalyticsPage
- Wrap with React Query QueryClientProvider
- Wrap with Layout component
- Include error boundary for crash handling

### Styling Guidelines
- Use Tailwind utility classes exclusively
- Color scheme:
  - Primary: Blue (indigo-600)
  - Success: Green (emerald-500)
  - Warning: Yellow (amber-500)
  - Danger: Red (rose-500)
  - Contexts: Use individual colors from seed data
- Typography:
  - Headings: font-bold, text sizes (text-2xl, text-xl, etc.)
  - Body: text-gray-700 dark:text-gray-300
- Spacing: consistent padding/margin (p-4, mb-6, etc.)
- Cards: rounded-lg, shadow-md, hover:shadow-lg
- Buttons: px-4 py-2, rounded, font-medium, transition colors
- Forms: proper labels, input styling, focus states

### Responsive Design
- Mobile-first approach
- Breakpoints: sm:, md:, lg:
- Sidebar collapses to hamburger menu on mobile
- Task cards stack vertically on mobile, grid on desktop
- Forms full-width on mobile, centered on desktop

### Loading and Error States
- Loading: Skeleton screens for initial load, spinners for actions
- Errors: Toast notifications or inline error messages
- Empty states: Friendly messages with call-to-action
- Success feedback: Brief toast notification after actions

### UX Enhancements
- Optimistic updates: Tasks appear immediately when created
- Keyboard shortcuts: Enter to submit forms, Escape to close modals
- Autofocus: First input field in forms
- Confirmation dialogs: Before deleting tasks
- Tooltips: On icon buttons for clarity
- Smooth transitions: Use Tailwind transition classes

## Environment Variables

### Backend (.env or appsettings.json)
```
DATABASE_URL=postgresql://user:password@host:port/database
ANTHROPIC_API_KEY=sk-ant-...
ASPNETCORE_ENVIRONMENT=Production
ASPNETCORE_URLS=http://0.0.0.0:$PORT
```

### Frontend (.env)
```
VITE_API_URL=https://your-api.railway.app/api
```

## Railway Deployment Configuration

### Backend Deployment
1. Create new Railway project
2. Add PostgreSQL database service (Railway will auto-generate DATABASE_URL)
3. Add .NET service from GitHub repo
4. Set environment variables: ANTHROPIC_API_KEY
5. Railway will auto-detect .NET and build
6. Ensure Program.cs uses PORT environment variable for binding
7. Enable automatic deployments from main branch

### Frontend Deployment
1. Add new service in same Railway project
2. Set build command: npm run build
3. Set start command: npm run preview (or use static file serving)
4. Set environment variable: VITE_API_URL (backend Railway URL)
5. Enable automatic deployments

### Database Migrations
- Run migrations automatically on startup in Program.cs
- Use: `context.Database.Migrate()` in development
- For production: use separate migration script or Railway scheduled job

## Testing Checklist

### Backend Testing
- Test all API endpoints with Postman or Thunder Client
- Verify CRUD operations for tasks
- Test AI integration with real API calls
- Verify database relationships and constraints
- Test error handling (invalid IDs, missing fields)
- Check CORS configuration works with frontend

### Frontend Testing
- Test all pages load correctly
- Verify task creation, editing, deletion flows
- Test context filtering and switching
- Verify AI features work (analyze, breakdown, suggest)
- Test responsive design on mobile/tablet/desktop
- Check loading and error states display properly
- Verify optimistic updates work correctly

### Integration Testing
- Create task â†’ appears in list immediately
- Complete task â†’ moves to completed, updates stats
- Delete task â†’ removes from list
- AI suggestions â†’ can apply to task form
- Context switching â†’ filters tasks correctly

## Documentation Requirements

### README.md
Include sections:
1. Project title and description
2. Live demo link and screenshots
3. Problem statement and solution
4. Features list
5. Tech stack with justification
6. Architecture overview
7. Setup instructions (local and deployment)
8. Environment variables needed
9. API documentation (endpoints)
10. What you learned
11. Future improvements
12. License

### Code Documentation
- Add XML comments to public methods in backend
- Add JSDoc comments to complex frontend functions
- Include inline comments for non-obvious logic
- Document AI prompts and their purpose
- Explain business logic decisions

## Success Criteria

The project is complete when:
1. âœ… Backend API is fully functional with all endpoints
2. âœ… Database schema is properly designed with relationships
3. âœ… AI integration works for all three features
4. âœ… Frontend displays all pages without errors
5. âœ… Tasks can be created, edited, completed, deleted
6. âœ… Context filtering and switching works
7. âœ… AI suggestions can be applied to tasks
8. âœ… Application is deployed and accessible via Railway
9. âœ… README is complete with demo link and screenshots
10. âœ… Code is clean, well-structured, and commented

## Final Notes

- Keep code clean and readable - this is a portfolio project
- Use consistent naming conventions (PascalCase for C#, camelCase for TypeScript)
- Handle errors gracefully with user-friendly messages
- Make the UI clean and professional, not flashy
- Ensure the app actually solves the context-switching problem effectively
- Test thoroughly before deploying
- Take screenshots/video for README before final deployment
- Aim for 4000-4500 lines total across both frontend and backend
- Focus on functionality first, polish second
- Make it work, then make it pretty

This project should take 5-7 days to complete with Cursor's assistance. Start with backend, get database working, then build frontend, and deploy last.